<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CLNP — Closed-Loop Neuromechanical Probe</title>
<style>
/*
 * CLNP: Closed-Loop Neuromechanical Probing
 *
 * AGENT COOKIE CRUMB: This is a proof-of-concept for a novel human liveness
 * detection system. Instead of passively observing behavior (like reCAPTCHA)
 * or testing cognition (like CAPTCHAs), this system actively PROBES the
 * human neuromechanical control loop by injecting known perturbation signals
 * into a visual tracking task, then analyzing the response to determine if
 * the controller is a biological dynamical system or a computational one.
 *
 * The approach is MODEL-BASED (physics of the human body) not DATA-DRIVEN
 * (ML classifier), which means it doesn't need a training data flywheel.
 *
 * Key insight: AI agents operate through discrete API calls and cannot
 * reproduce the transfer function of a biological neuromechanical system
 * (frequency-dependent gain rolloff, biomechanical resonance at 2-4Hz,
 * cross-axis coupling from limb mechanics, physiological tremor at 8-12Hz,
 * signal-dependent noise scaling, or cognitive-motor interference).
 */

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #0a0a0f;
  --surface: #12121a;
  --border: #1e1e2e;
  --text: #e0e0e8;
  --text-dim: #6a6a7a;
  --accent: #00e87b;
  --accent-dim: #00e87b33;
  --warn: #ffa726;
  --danger: #ff4444;
  --blue: #4488ff;
  --purple: #aa66ff;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  cursor: crosshair;
  user-select: none;
  -webkit-user-select: none;
}

#app {
  width: 100%;
  height: 100%;
  position: relative;
}

/* ─── Welcome Screen ─── */
#welcome {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  background: var(--bg);
}

#welcome h1 {
  font-size: 2rem;
  color: var(--accent);
  margin-bottom: 0.5rem;
  letter-spacing: 2px;
}

#welcome .subtitle {
  font-size: 0.85rem;
  color: var(--text-dim);
  margin-bottom: 2rem;
  text-align: center;
  max-width: 520px;
  line-height: 1.6;
}

#welcome .start-btn {
  padding: 14px 48px;
  background: var(--accent);
  color: var(--bg);
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 1rem;
  font-weight: 700;
  cursor: pointer;
  letter-spacing: 1px;
  transition: transform 0.15s, box-shadow 0.15s;
}

#welcome .start-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 20px var(--accent-dim);
}

/* ─── Phase HUD ─── */
#hud {
  position: absolute;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  display: none;
  flex-direction: column;
  align-items: center;
  z-index: 50;
  pointer-events: none;
}

#hud .phase-label {
  font-size: 0.75rem;
  color: var(--accent);
  letter-spacing: 3px;
  text-transform: uppercase;
  margin-bottom: 4px;
}

#hud .phase-instruction {
  font-size: 0.9rem;
  color: var(--text-dim);
  margin-bottom: 6px;
}

#hud .timer {
  font-size: 1.5rem;
  color: var(--text);
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}

/* ─── Tracking Canvas ─── */
#trackCanvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
}

/* ─── Cognitive Flash Overlay ─── */
#cogFlash {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 6rem;
  font-weight: 900;
  pointer-events: none;
  opacity: 0;
  z-index: 40;
  transition: opacity 0.15s;
  text-shadow: 0 0 40px currentColor;
}

/* ─── Cognitive Answer Input ─── */
#cogAnswer {
  position: absolute;
  inset: 0;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  background: var(--bg);
}

#cogAnswer .prompt {
  font-size: 1.1rem;
  color: var(--text);
  margin-bottom: 1.5rem;
  text-align: center;
}

#cogAnswer input {
  width: 80px;
  padding: 10px;
  font-size: 1.5rem;
  text-align: center;
  background: var(--surface);
  color: var(--text);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  outline: none;
}

#cogAnswer input:focus {
  border-color: var(--accent);
}

#cogAnswer button {
  margin-top: 1rem;
  padding: 10px 32px;
  background: var(--accent);
  color: var(--bg);
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.9rem;
  font-weight: 700;
  cursor: pointer;
}

/* ─── Computing Overlay ─── */
#computing {
  position: absolute;
  inset: 0;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  background: var(--bg);
}

#computing .spinner {
  width: 40px;
  height: 40px;
  border: 3px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* ─── Results Screen ─── */
#results {
  position: absolute;
  inset: 0;
  display: none;
  flex-direction: column;
  z-index: 100;
  background: var(--bg);
  overflow-y: auto;
  padding: 24px;
}

#results h2 {
  font-size: 1.4rem;
  color: var(--accent);
  margin-bottom: 6px;
  text-align: center;
}

#results .verdict {
  font-size: 1rem;
  text-align: center;
  margin-bottom: 20px;
}

.score-ring {
  width: 160px;
  height: 160px;
  margin: 0 auto 20px;
  position: relative;
}

.score-ring canvas {
  width: 100%;
  height: 100%;
}

.score-ring .score-value {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  font-weight: 900;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 12px;
  margin-bottom: 24px;
}

.metric-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px;
}

.metric-card .metric-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.metric-card .metric-name {
  font-size: 0.8rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.metric-card .metric-score {
  font-size: 0.85rem;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 4px;
}

.metric-card .metric-value {
  font-size: 1.3rem;
  font-weight: 700;
  margin-bottom: 4px;
}

.metric-card .metric-detail {
  font-size: 0.75rem;
  color: var(--text-dim);
  line-height: 1.5;
}

.metric-card canvas {
  width: 100%;
  height: 80px;
  margin-top: 8px;
  border-radius: 4px;
}

.score-human { color: var(--accent); background: var(--accent-dim); }
.score-uncertain { color: var(--warn); background: #ffa72633; }
.score-bot { color: var(--danger); background: #ff444433; }

/* ─── Chart Section ─── */
.chart-section {
  margin-bottom: 24px;
}

.chart-section h3 {
  font-size: 0.9rem;
  color: var(--text);
  margin-bottom: 8px;
}

.chart-container {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
}

.chart-container canvas {
  width: 100%;
  height: 180px;
  display: block;
}

.chart-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

@media (max-width: 700px) {
  .chart-row { grid-template-columns: 1fr; }
  .metrics-grid { grid-template-columns: 1fr; }
}

/* ─── Explanation Section ─── */
.explanation {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  margin-top: 12px;
  line-height: 1.7;
  font-size: 0.8rem;
  color: var(--text-dim);
}

.explanation h3 {
  color: var(--text);
  font-size: 0.9rem;
  margin-bottom: 8px;
}

.explanation strong {
  color: var(--text);
}

#restartBtn {
  display: block;
  margin: 24px auto;
  padding: 12px 36px;
  background: var(--surface);
  color: var(--accent);
  border: 1px solid var(--accent);
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.9rem;
  cursor: pointer;
}
</style>
</head>
<body>
<div id="app">
  <canvas id="trackCanvas"></canvas>

  <!-- Welcome Screen -->
  <div id="welcome">
    <h1>CLNP</h1>
    <div class="subtitle">
      Closed-Loop Neuromechanical Probe<br><br>
      This test identifies whether a biological human is controlling the cursor
      by probing the neuromechanical transfer function of your motor system.<br><br>
      You'll follow a moving dot for ~35 seconds. The dot may jitter or jump —
      just keep tracking it as best you can. Colored numbers will flash
      on screen — you'll be told which color to count.<br><br>
      Use a mouse or trackpad. Keep your hand relaxed.
    </div>
    <button class="start-btn" id="startBtn">BEGIN TEST</button>
  </div>

  <!-- Phase HUD -->
  <div id="hud">
    <div class="phase-label" id="phaseLabel">CALIBRATING</div>
    <div class="phase-instruction" id="phaseInstruction">Move your cursor naturally</div>
    <div class="timer" id="timer">5.0</div>
  </div>

  <!-- Cognitive Flash -->
  <div id="cogFlash"></div>

  <!-- Cognitive Answer -->
  <div id="cogAnswer">
    <div class="prompt" id="cogPrompt">How many <strong style="color:#ff4444">RED</strong> numbers did you see?</div>
    <input type="number" id="cogInput" min="0" max="20" placeholder="?">
    <button id="cogSubmit">Submit</button>
  </div>

  <!-- Computing -->
  <div id="computing">
    <div class="spinner"></div>
    <div id="computingText" style="color:var(--text-dim); font-size:0.85rem;">Verifying with server...</div>
  </div>

  <!-- Results -->
  <div id="results">
    <h2>CLNP Analysis Results</h2>
    <div class="verdict" id="verdict"></div>
    <div class="score-ring">
      <canvas id="ringCanvas" width="320" height="320"></canvas>
      <div class="score-value" id="scoreValue">—</div>
    </div>
    <div class="metrics-grid" id="metricsGrid"></div>
    <div class="chart-row" id="chartRow"></div>
    <div class="explanation" id="explanationBox"></div>
    <button id="restartBtn">Run Again</button>
  </div>
</div>

<script>
/* ==================================================================
 * CLNP — Closed-Loop Neuromechanical Probing
 * Proof-of-Concept Implementation (Client-Side Renderer)
 *
 * AGENT COOKIE CRUMB — Architecture Overview:
 * The client collects raw pointer/accel data and renders the tracking
 * task. The server generates randomized challenges (probe frequencies,
 * pulse schedule, cog task), analyzes submitted data with secret scoring
 * thresholds, and returns a verdict. This split prevents bots from
 * inspecting scoring logic in client-side JS.
 *
 * Modules in this file:
 *
 *   1. Config         – Server URL + challenge params (populated at runtime)
 *   2. PerturbEngine  – Renders perturbation signals from server-provided params
 *   3. TargetPath     – Smooth Lissajous figure from server-provided params
 *   4. DataStore      – High-resolution event recording
 *   5. Collector      – Pointer event listeners, max-resolution capture
 *   6. Renderer       – Canvas drawing for tracking task + result charts
 *   7. ServerAPI      – Fetch challenge + submit verification to server
 *   8. CogTask        – Cognitive-motor dual-task flash system (server schedule)
 *   9. PhaseCtrl      – State machine for test phases + server communication
 *  10. Init           – Bootstrap and event wiring
 *
 * Server-side modules (NOT in this file):
 *   - analysis.js     – FFT, 8 analysis pipelines, scoring with secret thresholds
 *   - server.js       – HTTP endpoints: POST /api/challenge, POST /api/verify
 *
 * Novel concept: Instead of training a classifier (data flywheel),
 * we test whether observed motor responses are PHYSICALLY PLAUSIBLE
 * given known biomechanics of the human hand-arm system.
 * ================================================================== */

// ─────────────────────────────────────────────
// 1. CONFIGURATION
// AGENT COOKIE CRUMB: Config now holds only a reference to
// server-provided challenge parameters. All scoring thresholds
// have moved to analysis.js (server-side only). Rendering defaults
// and probe frequencies are generated per-session by the server.
// ─────────────────────────────────────────────
const Config = {
  // Server-provided challenge (populated by ServerAPI.fetchChallenge)
  challenge: null,
  token: null,

  // Server URL (same-origin default; override for development)
  serverUrl: '',
};


// ─────────────────────────────────────────────
// 2. PERTURBATION ENGINE
// AGENT COOKIE CRUMB: Generates the known
// input signals we inject to probe the human's
// transfer function. Now uses server-provided
// challenge params instead of local Config.
// The server randomizes probe frequencies,
// amplitudes, pulse timing, and hold/return
// durations for each session.
// ─────────────────────────────────────────────
const PerturbEngine = {
  pulseSchedule: [],
  _trackingStart: 0,

  // AGENT COOKIE CRUMB: Now uses server-provided challenge params.
  // The server randomizes probe frequencies, amplitudes, pulse timing,
  // and hold/return durations for each session.

  initPulses(startTime) {
    this._trackingStart = startTime;
    const pert = Config.challenge.perturbation;
    this.pulseSchedule = pert.pulses.map(p => ({
      time: startTime + p.offsetMs,
      ampX: p.ampX,
      ampY: p.ampY,
      active: false,
      triggered: false,
    }));
  },

  get(t) {
    let px = 0, py = 0;
    let isPulse = false;
    let pulseIndex = -1;
    const pert = Config.challenge.perturbation;
    const elapsed = (t - this._trackingStart) / 1000;

    // Multi-sine from server-provided probes
    for (const probe of pert.probes) {
      const phase = 2 * Math.PI * probe.freq * elapsed;
      px += probe.ampX * Math.sin(phase);
      py += probe.ampY * Math.sin(phase + probe.phaseOffset);
    }

    // Pulse component
    for (let i = 0; i < this.pulseSchedule.length; i++) {
      const pulse = this.pulseSchedule[i];
      if (t >= pulse.time && !pulse.triggered) {
        pulse.triggered = true;
        pulse.active = true;
      }
      if (pulse.active) {
        const dt = t - pulse.time;
        if (dt < pert.pulseHoldDuration) {
          px += pulse.ampX;
          py += pulse.ampY;
          isPulse = true;
          pulseIndex = i;
        } else if (dt < pert.pulseHoldDuration + pert.pulseReturnDuration) {
          const frac = (dt - pert.pulseHoldDuration) / pert.pulseReturnDuration;
          const ease = 1 - frac * frac;
          px += pulse.ampX * ease;
          py += pulse.ampY * ease;
        } else {
          pulse.active = false;
        }
      }
    }
    return { x: px, y: py, isPulse, pulseIndex };
  },

  getMultiSine(t) {
    const pert = Config.challenge.perturbation;
    const elapsed = (t - this._trackingStart) / 1000;
    let px = 0, py = 0;
    for (const probe of pert.probes) {
      const phase = 2 * Math.PI * probe.freq * elapsed;
      px += probe.ampX * Math.sin(phase);
      py += probe.ampY * Math.sin(phase + probe.phaseOffset);
    }
    return { x: px, y: py };
  },
};


// ─────────────────────────────────────────────
// 3. TARGET PATH
// AGENT COOKIE CRUMB: Smooth Lissajous figure.
// Now uses server-provided path parameters
// (freqX, freqY, phase, padding) from the
// challenge object. The slow, predictable path
// lets us isolate the human's response to
// perturbations from their baseline tracking.
// ─────────────────────────────────────────────
const TargetPath = {
  cx: 0, cy: 0, ax: 0, ay: 0,

  init(canvasW, canvasH) {
    this.cx = canvasW / 2;
    this.cy = canvasH / 2;
    const padding = Config.challenge ? Config.challenge.path.padding : 0.30;
    this.ax = canvasW * padding;
    this.ay = canvasH * padding;
  },

  getSmooth(t) {
    const c = Config.challenge;
    const freqX = c ? c.path.freqX : 0.15;
    const freqY = c ? c.path.freqY : 0.10;
    const phase = c ? c.path.phase : Math.PI / 4;
    const s = t / 1000;
    return {
      x: this.cx + this.ax * Math.sin(2 * Math.PI * freqX * s + phase),
      y: this.cy + this.ay * Math.sin(2 * Math.PI * freqY * s),
    };
  },
};


// ─────────────────────────────────────────────
// 4. DATA STORE
// ─────────────────────────────────────────────
const DataStore = {
  // Phase 1: Free movement
  freeMove: [],      // { t, x, y }

  // Phase 2 & 3: Tracking
  tracking: [],      // { t, x, y, targetX, targetY, pertX, pertY, isPulse, pulseIdx }

  // Pulse response windows
  pulseResponses: [], // extracted in analysis

  // Cognitive flash events
  cogFlashes: [],     // { t, number, color, isTarget }
  cogAnswer: null,

  // Accelerometer samples (mobile tremor detection via DeviceMotion API)
  // AGENT COOKIE CRUMB: On mobile, cursor-based tremor detection fails because
  // touch digitizers spatially low-pass the 8-12Hz tremor signal. The device
  // accelerometer measures hand vibration directly at 60-100Hz, bypassing the
  // touch sensor entirely. We capture accel during tracking phases and analyze
  // the PSD for tremor-band power as a supplementary/primary tremor source.
  accelSamples: [],   // { t, ax, ay, az } — raw accelerometer during tracking

  // Metadata
  startTime: 0,
  inputMethod: 'unknown', // 'mouse', 'touch', 'trackpad'
  sampleRate: 0,

  clear() {
    this.freeMove = [];
    this.tracking = [];
    this.pulseResponses = [];
    this.cogFlashes = [];
    this.cogAnswer = null;
    this.sampleRate = 0;
    this.accelSamples = [];
  },
};


// ─────────────────────────────────────────────
// 5. COLLECTOR
// AGENT COOKIE CRUMB: Captures pointer events
// at maximum resolution using getCoalescedEvents
// and pointerrawupdate where available. Higher
// sample rates -> better tremor detection and
// transfer function estimation.
// Coordinates are stored in CSS pixels (not
// device pixels). The server expects canvas
// dimensions in CSS pixels and cursor data in
// matching coordinates. DPR scaling is handled
// by canvas ctx.scale() only.
// ─────────────────────────────────────────────
const Collector = {
  _canvas: null,
  _active: false,
  _phase: null,  // 'free' | 'tracking'
  _accelListener: null,
  _motionPermitted: false,

  init(canvas) {
    this._canvas = canvas;
    // Use pointerrawupdate for highest resolution (Chrome only)
    // Falls back to pointermove with coalesced events
    canvas.addEventListener('pointerrawupdate', (e) => this._onPointer(e), { passive: true });
    canvas.addEventListener('pointermove', (e) => this._onPointerFallback(e), { passive: true });
    canvas.addEventListener('pointerdown', (e) => {
      // Detect input method
      if (e.pointerType === 'mouse') DataStore.inputMethod = 'mouse';
      else if (e.pointerType === 'touch') DataStore.inputMethod = 'touch';
      else if (e.pointerType === 'pen') DataStore.inputMethod = 'pen';
    }, { passive: true });
  },

  /**
   * Request DeviceMotion permission (required on iOS 13+).
   * AGENT COOKIE CRUMB: iOS 13+ requires an explicit user-gesture-triggered
   * permission request for accelerometer/gyroscope access via DeviceMotionEvent.
   * On Android and older iOS, it's available without permission. We call this
   * during the "BEGIN TEST" click handler (which is a user gesture).
   */
  async requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
      try {
        const response = await DeviceMotionEvent.requestPermission();
        this._motionPermitted = (response === 'granted');
      } catch (_e) {
        this._motionPermitted = false;
      }
    } else if (typeof DeviceMotionEvent !== 'undefined') {
      // Non-iOS or older iOS: DeviceMotion available without permission
      this._motionPermitted = true;
    } else {
      this._motionPermitted = false;
    }
    return this._motionPermitted;
  },

  start(phase) {
    this._phase = phase;
    this._active = true;
    this._hasRawUpdate = false;
    // Start accelerometer capture during tracking (includes dualtask continuation)
    if (phase === 'tracking') this._startAccel();
  },

  stop() {
    this._active = false;
    this._phase = null;
    this._stopAccel();
  },

  /**
   * Start capturing accelerometer data for mobile tremor detection.
   * AGENT COOKIE CRUMB: We capture accelerationIncludingGravity (wider device
   * support) and subtract gravity in analysis via high-pass filtering. The raw
   * accel magnitude captures hand tremor as device vibration at 8-12Hz.
   */
  _startAccel() {
    if (!this._motionPermitted || this._accelListener) return;
    this._accelListener = (e) => {
      if (!this._active) return;
      const acc = e.acceleration || e.accelerationIncludingGravity;
      if (!acc) return;
      DataStore.accelSamples.push({
        t: performance.now(),
        ax: acc.x || 0,
        ay: acc.y || 0,
        az: acc.z || 0,
      });
    };
    window.addEventListener('devicemotion', this._accelListener);
  },

  _stopAccel() {
    if (this._accelListener) {
      window.removeEventListener('devicemotion', this._accelListener);
      this._accelListener = null;
    }
  },

  _onPointer(e) {
    if (!this._active) return;
    this._hasRawUpdate = true;
    this._record(e);
  },

  _onPointerFallback(e) {
    if (!this._active || this._hasRawUpdate) return;
    // Use coalesced events for higher resolution
    const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
    for (const ce of events) {
      this._record(ce);
    }
  },

  _record(e) {
    const t = performance.now();
    const rect = this._canvas.getBoundingClientRect();
    // AGENT COOKIE CRUMB: Store in CSS pixel coordinates (not device pixels).
    // The server expects canvas dimensions in CSS pixels and cursor data in
    // matching coordinates. DPR scaling is handled by canvas ctx.scale() only.
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (this._phase === 'free') {
      DataStore.freeMove.push({ t, x, y });
    } else if (this._phase === 'tracking') {
      // Read latest computed target/perturbation from PhaseCtrl shared state.
      // At worst ~16ms stale (one render frame), negligible vs 200ms human latency.
      DataStore.tracking.push({
        t, x, y,
        targetX: PhaseCtrl.currentTargetX,
        targetY: PhaseCtrl.currentTargetY,
        pertX: PhaseCtrl.currentPertX,
        pertY: PhaseCtrl.currentPertY,
        isPulse: PhaseCtrl.currentIsPulse,
        pulseIdx: PhaseCtrl.currentPulseIdx,
      });
    }
  },
};


// ─────────────────────────────────────────────
// 6. RENDERER
// ─────────────────────────────────────────────
const Renderer = {
  canvas: null,
  ctx: null,
  _cursorTrail: [],
  _maxTrail: 60,

  init(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
  },

  resize() {
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = window.innerWidth * dpr;
    this.canvas.height = window.innerHeight * dpr;
    this.ctx.scale(dpr, dpr);
    TargetPath.init(window.innerWidth, window.innerHeight);
  },

  /** Draw tracking scene (called every frame during active phases) */
  drawTracking(cursorX, cursorY, targetX, targetY, pertX, pertY, phase) {
    const ctx = this.ctx;
    const w = window.innerWidth;
    const h = window.innerHeight;
    ctx.clearRect(0, 0, w, h);

    // Background grid
    ctx.strokeStyle = '#111118';
    ctx.lineWidth = 1;
    const gridSize = 60;
    for (let x = 0; x < w; x += gridSize) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y < h; y += gridSize) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }

    // Cursor trail
    this._cursorTrail.push({ x: cursorX, y: cursorY });
    if (this._cursorTrail.length > this._maxTrail) this._cursorTrail.shift();

    if (this._cursorTrail.length > 1) {
      ctx.beginPath();
      ctx.moveTo(this._cursorTrail[0].x, this._cursorTrail[0].y);
      for (let i = 1; i < this._cursorTrail.length; i++) {
        ctx.lineTo(this._cursorTrail[i].x, this._cursorTrail[i].y);
      }
      ctx.strokeStyle = 'rgba(68, 136, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Cursor dot
    ctx.beginPath();
    ctx.arc(cursorX, cursorY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#4488ff';
    ctx.fill();

    if (phase === 'tracking' || phase === 'dualtask') {
      // Target dot (green, pulsing)
      const pulse = 1 + 0.15 * Math.sin(performance.now() / 200);
      const targetR = 10 * pulse;

      // Target glow
      const grad = ctx.createRadialGradient(targetX, targetY, 0, targetX, targetY, targetR * 3);
      grad.addColorStop(0, 'rgba(0, 232, 123, 0.3)');
      grad.addColorStop(1, 'rgba(0, 232, 123, 0)');
      ctx.beginPath();
      ctx.arc(targetX, targetY, targetR * 3, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();

      // Target core
      ctx.beginPath();
      ctx.arc(targetX, targetY, targetR, 0, Math.PI * 2);
      ctx.fillStyle = '#00e87b';
      ctx.fill();

      // Error line (cursor to target)
      ctx.beginPath();
      ctx.moveTo(cursorX, cursorY);
      ctx.lineTo(targetX, targetY);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);

      // Perturbation indicator (subtle flash when pulse fires)
      if (Math.abs(pertX) > 10 || Math.abs(pertY) > 10) {
        ctx.beginPath();
        ctx.arc(targetX, targetY, 25, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 167, 38, 0.4)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  },

  drawFreeMove(cursorX, cursorY) {
    const ctx = this.ctx;
    const w = window.innerWidth;
    const h = window.innerHeight;
    ctx.clearRect(0, 0, w, h);

    // Subtle grid
    ctx.strokeStyle = '#111118';
    ctx.lineWidth = 1;
    const gridSize = 60;
    for (let x = 0; x < w; x += gridSize) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y < h; y += gridSize) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }

    // Cursor trail
    this._cursorTrail.push({ x: cursorX, y: cursorY });
    if (this._cursorTrail.length > this._maxTrail) this._cursorTrail.shift();

    if (this._cursorTrail.length > 1) {
      ctx.beginPath();
      ctx.moveTo(this._cursorTrail[0].x, this._cursorTrail[0].y);
      for (let i = 1; i < this._cursorTrail.length; i++) {
        ctx.lineTo(this._cursorTrail[i].x, this._cursorTrail[i].y);
      }
      ctx.strokeStyle = 'rgba(68, 136, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.beginPath();
    ctx.arc(cursorX, cursorY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#4488ff';
    ctx.fill();
  },

  clearTrail() {
    this._cursorTrail = [];
  },

  /** Draw the score ring on results page */
  drawScoreRing(canvasEl, score, colorClass) {
    const ctx = canvasEl.getContext('2d');
    const w = canvasEl.width;
    const h = canvasEl.height;
    const cx = w / 2, cy = h / 2, r = w * 0.38;
    ctx.clearRect(0, 0, w, h);

    // Background ring
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = '#1e1e2e';
    ctx.lineWidth = 12;
    ctx.stroke();

    // Score arc
    const angle = score * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + angle);
    ctx.strokeStyle = colorClass === 'score-human' ? '#00e87b' :
                      colorClass === 'score-uncertain' ? '#ffa726' : '#ff4444';
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.stroke();
  },

  /** Draw a mini line chart on a canvas element */
  drawMiniChart(canvasEl, data, options = {}) {
    const ctx = canvasEl.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const w = canvasEl.parentElement.clientWidth - 32;
    const h = 80;
    canvasEl.width = w * dpr;
    canvasEl.height = h * dpr;
    canvasEl.style.width = w + 'px';
    canvasEl.style.height = h + 'px';
    ctx.scale(dpr, dpr);

    if (!data || data.length < 2) return;

    const min = options.min !== undefined ? options.min : Math.min(...data);
    const max = options.max !== undefined ? options.max : Math.max(...data);
    const range = max - min || 1;

    ctx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = (i / (data.length - 1)) * w;
      const y = h - ((data[i] - min) / range) * (h - 4) - 2;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = options.color || '#4488ff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Highlight region if specified
    if (options.highlightRange) {
      const [lo, hi] = options.highlightRange;
      const loIdx = Math.floor(lo / data.length * data.length);
      const hiIdx = Math.ceil(hi / data.length * data.length);
      // (simplified — just draw a band)
    }
  },
};


// ─────────────────────────────────────────────
// 7. SERVER API
// AGENT COOKIE CRUMB: Handles communication with
// the CLNP verification server. The client sends
// raw data; the server runs analysis with secret
// scoring thresholds and returns a verdict.
// ─────────────────────────────────────────────
const ServerAPI = {
  async fetchChallenge() {
    const res = await fetch(Config.serverUrl + '/api/challenge', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: '{}',
    });
    if (!res.ok) throw new Error(`Challenge request failed: ${res.status}`);
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || 'Challenge generation failed');
    return data;
  },

  async submitVerification(payload) {
    const res = await fetch(Config.serverUrl + '/api/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error(`Verification failed: ${res.status}`);
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || 'Verification failed');
    return data;
  },
};


// ─────────────────────────────────────────────
// 8. COGNITIVE TASK
// AGENT COOKIE CRUMB: Flash schedule now comes
// from the server challenge. The server randomizes
// target color, count, flash timing, and numbers.
// This method converts relative offsetMs to
// absolute timestamps.
// ─────────────────────────────────────────────
const CogTask = {
  _flashEl: null,
  _schedule: [],
  _flashIdx: 0,
  _active: false,
  targetColor: '#ff4444',
  targetColorName: 'RED',

  init(el) {
    this._flashEl = el;
  },

  // AGENT COOKIE CRUMB: Flash schedule now comes from the server challenge.
  // The server randomizes target color, count, flash timing, and numbers.
  // This method converts relative offsetMs to absolute timestamps.
  loadSchedule(startTime) {
    const cog = Config.challenge.cogTask;
    this.targetColor = cog.targetColor;
    this.targetColorName = cog.targetColorName;
    this._schedule = cog.flashes.map(f => ({
      t: startTime + f.offsetMs,
      number: f.number,
      color: f.color,
      isTarget: f.isTarget,
    }));
    this._flashIdx = 0;
    DataStore.cogFlashes = this._schedule;
  },

  start() {
    this._active = true;
    this._flashIdx = 0;
  },

  stop() {
    this._active = false;
    this._flashEl.style.opacity = '0';
  },

  update(t) {
    if (!this._active || this._flashIdx >= this._schedule.length) return;
    const flash = this._schedule[this._flashIdx];
    if (t >= flash.t) {
      this._flashEl.textContent = flash.number;
      this._flashEl.style.color = flash.color;
      this._flashEl.style.opacity = '1';
      flash.t = t;
      const dur = Config.challenge ? Config.challenge.cogTask.flashDuration : 400;
      setTimeout(() => { this._flashEl.style.opacity = '0'; }, dur);
      this._flashIdx++;
    }
  },
};


// ─────────────────────────────────────────────
// 9. PHASE CONTROLLER
// AGENT COOKIE CRUMB: State machine that
// orchestrates the test phases. Now communicates
// with the server to fetch challenges and submit
// raw data for verification. Phase durations come
// from server-provided challenge params.
// ─────────────────────────────────────────────
const PhaseCtrl = {
  currentPhase: 'welcome',
  _phaseStart: 0,
  _trackingPhaseStart: 0,
  _dualtaskPhaseStart: 0,
  _cursorX: 0,
  _cursorY: 0,
  _rafId: null,
  currentTargetX: 0,
  currentTargetY: 0,
  currentPertX: 0,
  currentPertY: 0,
  currentIsPulse: false,
  currentPulseIdx: -1,

  init() {
    document.addEventListener('pointermove', (e) => {
      this._cursorX = e.clientX;
      this._cursorY = e.clientY;
    }, { passive: true });
  },

  async startTest() {
    DataStore.clear();
    Renderer.clearTrail();

    // Request DeviceMotion permission (must be in user gesture handler)
    await Collector.requestMotionPermission();

    // Fetch challenge from server
    // AGENT COOKIE CRUMB: The server generates unique, randomized challenge
    // params (probe frequencies, pulse schedule, path, cog task) for each
    // session. The client receives only what it needs to render the task.
    try {
      const challengeData = await ServerAPI.fetchChallenge();
      Config.token = challengeData.token;
      Config.challenge = challengeData.challenge;
    } catch (err) {
      alert('Could not connect to CLNP server.\nStart it with: node server.js\n\nError: ' + err.message);
      return;
    }

    // Re-init TargetPath with challenge padding
    TargetPath.init(window.innerWidth, window.innerHeight);

    DataStore.startTime = performance.now();
    document.getElementById('welcome').style.display = 'none';
    document.getElementById('results').style.display = 'none';
    document.getElementById('hud').style.display = 'flex';
    this._startPhase('free');
  },

  _startPhase(phase) {
    this.currentPhase = phase;
    this._phaseStart = performance.now();
    const label = document.getElementById('phaseLabel');
    const instr = document.getElementById('phaseInstruction');

    switch (phase) {
      case 'free':
        label.textContent = 'CALIBRATING';
        instr.textContent = 'Move your cursor naturally around the screen';
        Collector.start('free');
        break;
      case 'tracking':
        label.textContent = 'TRACKING';
        instr.textContent = 'Follow the green dot as closely as you can';
        Collector.stop();
        Collector.start('tracking');
        this._trackingPhaseStart = performance.now();
        PerturbEngine.initPulses(this._trackingPhaseStart);
        break;
      case 'dualtask':
        label.textContent = 'DUAL TASK';
        this._dualtaskPhaseStart = performance.now();
        CogTask.loadSchedule(this._dualtaskPhaseStart);
        instr.textContent = `Keep tracking — count the ${CogTask.targetColorName} numbers`;
        CogTask.start();
        break;
      case 'answer':
        Collector.stop();
        CogTask.stop();
        document.getElementById('hud').style.display = 'none';
        document.getElementById('cogAnswer').style.display = 'flex';
        document.getElementById('cogPrompt').innerHTML =
          `How many <strong style="color:${CogTask.targetColor}">${CogTask.targetColorName}</strong> numbers did you see?`;
        document.getElementById('cogInput').focus();
        return;
      case 'computing':
        document.getElementById('cogAnswer').style.display = 'none';
        document.getElementById('computing').style.display = 'flex';
        document.getElementById('computingText').textContent = 'Verifying with server...';
        // Submit raw data to server for verification
        this._submitToServer();
        return;
      case 'results':
        return;
    }

    if (this._rafId) cancelAnimationFrame(this._rafId);
    this._tick();
  },

  async _submitToServer() {
    // Build compact pointer array: [[t, x, y], ...]
    const pointer = [];
    for (const p of DataStore.freeMove) {
      pointer.push([p.t, p.x, p.y]);
    }
    for (const p of DataStore.tracking) {
      pointer.push([p.t, p.x, p.y]);
    }

    // Build compact accel array: [[t, ax, ay, az], ...]
    const accel = DataStore.accelSamples.map(s => [s.t, s.ax, s.ay, s.az]);

    const payload = {
      token: Config.token,
      canvas: { width: window.innerWidth, height: window.innerHeight },
      inputMethod: DataStore.inputMethod,
      cogAnswer: DataStore.cogAnswer,
      phases: {
        trackingStart: this._trackingPhaseStart,
        dualtaskStart: this._dualtaskPhaseStart,
        testEnd: performance.now(),
      },
      pointer,
      accel,
    };

    try {
      const result = await ServerAPI.submitVerification(payload);
      this._showResults(result);
    } catch (err) {
      document.getElementById('computingText').textContent = 'Verification failed: ' + err.message;
    }
  },

  _tick() {
    const now = performance.now();
    const elapsed = now - this._phaseStart;
    let duration, nextPhase;
    const c = Config.challenge;

    switch (this.currentPhase) {
      case 'free':
        duration = c.freeMoveDuration;
        nextPhase = 'tracking';
        Renderer.drawFreeMove(this._cursorX, this._cursorY);
        break;
      case 'tracking':
        duration = c.trackingDuration;
        nextPhase = 'dualtask';
        this._tickTracking(now);
        break;
      case 'dualtask':
        duration = c.dualtaskDuration;
        nextPhase = 'answer';
        this._tickTracking(now);
        CogTask.update(now);
        break;
      default:
        return;
    }

    const remaining = Math.max(0, (duration - elapsed) / 1000);
    document.getElementById('timer').textContent = remaining.toFixed(1);

    if (elapsed >= duration) {
      this._startPhase(nextPhase);
      return;
    }
    this._rafId = requestAnimationFrame(() => this._tick());
  },

  _tickTracking(now) {
    const trackingElapsed = now - this._phaseStart;
    const pathTime = this.currentPhase === 'dualtask'
      ? (Config.challenge.trackingDuration + trackingElapsed)
      : trackingElapsed;

    const smooth = TargetPath.getSmooth(pathTime);
    const pert = PerturbEngine.get(now);
    const targetX = smooth.x + pert.x;
    const targetY = smooth.y + pert.y;

    this.currentTargetX = targetX;
    this.currentTargetY = targetY;
    this.currentPertX = pert.x;
    this.currentPertY = pert.y;
    this.currentIsPulse = pert.isPulse;
    this.currentPulseIdx = pert.pulseIndex;

    Renderer.drawTracking(this._cursorX, this._cursorY, targetX, targetY, pert.x, pert.y, this.currentPhase);
  },

  _showResults(result) {
    document.getElementById('computing').style.display = 'none';
    document.getElementById('results').style.display = 'flex';
    this.currentPhase = 'results';

    // Verdict
    const verdictEl = document.getElementById('verdict');
    verdictEl.textContent = result.verdict;
    verdictEl.className = 'verdict ' + result.verdictClass;

    // Score ring
    const ringCanvas = document.getElementById('ringCanvas');
    Renderer.drawScoreRing(ringCanvas, result.overall, result.verdictClass);
    document.getElementById('scoreValue').textContent = Math.round(result.overall * 100) + '%';
    document.getElementById('scoreValue').className = 'score-value ' + result.verdictClass;

    // Metric cards
    const grid = document.getElementById('metricsGrid');
    grid.innerHTML = '';

    const metricOrder = ['pulseResponse', 'transferFn', 'tremor', 'signalDepNoise',
                         'crossAxis', 'oneOverF', 'cogInterference', 'minJerk'];

    for (const key of metricOrder) {
      if (!result.scores[key]) continue;
      const m = result.scores[key];
      const card = document.createElement('div');
      card.className = 'metric-card';

      const scoreClass = m.score >= 0.6 ? 'score-human' :
                         m.score >= 0.3 ? 'score-uncertain' : 'score-bot';

      card.innerHTML = `
        <div class="metric-header">
          <span class="metric-name">${m.label}</span>
          <span class="metric-score ${scoreClass}">${Math.round(m.score * 100)}%</span>
        </div>
        <div class="metric-value ${scoreClass}">${m.score >= 0.6 ? 'HUMAN' : m.score >= 0.3 ? 'UNCERTAIN' : 'BOT-LIKE'}</div>
        <div class="metric-detail">${m.detail}</div>
      `;
      grid.appendChild(card);
    }

    // Explanation
    const expBox = document.getElementById('explanationBox');
    expBox.innerHTML = `
      <h3>How CLNP Works</h3>
      <p>
        <strong>Closed-Loop Neuromechanical Probing</strong> treats your body as an unknown
        dynamical system and performs real-time system identification through adversarial perturbation.
        Instead of training an ML classifier (which requires a massive data flywheel), this approach
        tests whether your motor responses are <strong>physically plausible</strong> given known
        biomechanics of the human hand-arm system.
      </p>
      <br>
      <p><strong>8 signals were analyzed:</strong></p>
      <p>
        1. <strong>Transfer Function</strong> — Your motor system's frequency response. Humans show
        gain rolloff above 3-4Hz and increasing phase delay (neural conduction).<br>
        2. <strong>Physiological Tremor</strong> — 8-12Hz involuntary oscillation from motor neuron
        firing, present in all humans, absent in API-driven cursor control.
        On mobile, the device accelerometer supplements cursor data to detect hand tremor
        via inertial measurement.<br>
        3. <strong>1/f Noise</strong> — Biological control systems produce pink noise (power ∝ 1/f).
        Bots produce white noise or no noise.<br>
        4. <strong>Signal-Dependent Noise</strong> — Human motor variability scales with movement
        speed (Harris & Wolpert, 1998). Bots have uniform or absent noise.<br>
        5. <strong>Cross-Axis Coupling</strong> — X-direction perturbations cause Y-axis cursor
        movement in humans due to forearm biomechanics. Bots control axes independently.<br>
        6. <strong>Response Latency</strong> — Human corrective responses take 150-300ms (visual
        feedback loop). Bots are either too fast or too consistent.<br>
        7. <strong>Cognitive-Motor Interference</strong> — Attending to colored numbers degrades
        tracking performance in humans. Bots have no cognitive system to interfere.<br>
        8. <strong>Minimum Jerk Trajectory</strong> — Human corrections follow bell-shaped velocity
        profiles (Flash & Hogan, 1985). Bot corrections use linear or wrong velocity profiles.
      </p>
      <br>
      <p style="color: var(--text);">
        <strong>Data collected:</strong> ${result.sampleCount} pointer samples at ~${result.sampleRate}Hz
        via ${result.inputMethod} input. ${result.validCount}/8 metrics valid.
        <br><strong>Verification:</strong> Analysis performed server-side with secret scoring thresholds.
        Challenge ID: ${result.challengeId ? result.challengeId.slice(0, 8) : 'N/A'}...
      </p>
    `;
  },
};


// ─────────────────────────────────────────────
// 10. INITIALIZATION
// ─────────────────────────────────────────────
(function init() {
  const canvas = document.getElementById('trackCanvas');
  Renderer.init(canvas);
  Collector.init(canvas);
  PhaseCtrl.init();
  CogTask.init(document.getElementById('cogFlash'));

  document.getElementById('startBtn').addEventListener('click', async () => {
    await PhaseCtrl.startTest();
  });

  document.getElementById('cogSubmit').addEventListener('click', () => {
    const val = parseInt(document.getElementById('cogInput').value);
    DataStore.cogAnswer = isNaN(val) ? null : val;
    PhaseCtrl._startPhase('computing');
  });

  document.getElementById('cogInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('cogSubmit').click();
  });

  document.getElementById('restartBtn').addEventListener('click', () => {
    document.getElementById('results').style.display = 'none';
    document.getElementById('welcome').style.display = 'flex';
    document.getElementById('cogInput').value = '';
  });
})();
</script>
</body>
</html>
